import{l as c}from"./CollectionFlattener-1d70a253.js";import{e as l,c as p}from"./subclass-f7409b1b.js";import{V as f}from"./Collection-aa6ef54b.js";import{n as u}from"./collectionUtils-b6e30316.js";import{s as d}from"./Error-21d1d076.js";import{S as b}from"./promiseUtils-1d963c7c.js";import{y as m}from"./JSONSupport-acf2865c.js";import"./typedArrayUtil-2af43698.js";import{b as g}from"./Layer-668dff8a.js";function T(i){return new c({getCollections:()=>[i.tables,i.layers],getChildrenFunction:r=>{const a=[];return"tables"in r&&a.push(r.tables),"layers"in r&&a.push(r.layers),a},itemFilterFunction:r=>{const a=r.parent;return!!a&&"tables"in a&&a.tables.includes(r)}})}function _(i){for(const r of i.values())r==null||r.destroy();i.clear()}function y(i,r,a){let e,t;if(i)for(let o=0,n=i.length;o<n;o++){if(e=i.at(o),(e==null?void 0:e[r])===a)return e;if((e==null?void 0:e.type)==="group"&&(t=y(e.layers,r,a),t))return t}}const F=i=>{let r=class extends i{constructor(...e){super(...e),this.layers=new f;const t=s=>{s.parent&&"remove"in s.parent&&s.parent.remove(s)},o=s=>{s.parent=this,this.layerAdded(s),s.type!=="elevation"&&s.type!=="base-elevation"||d.getLogger(this).error(`Layer 'title:${s.title}, id:${s.id}' of type '${s.type}' is not supported as an operational layer and will therefore be ignored.`)},n=s=>{s.parent=null,this.layerRemoved(s)};this.addHandles([this.layers.on("before-add",s=>t(s.item)),this.layers.on("after-add",s=>o(s.item)),this.layers.on("after-remove",s=>n(s.item))])}destroy(){const e=this.layers.toArray();for(const t of e)t.destroy();this.layers.destroy()}set layers(e){this._set("layers",u(e,this._get("layers")))}add(e,t){const o=this.layers;if(t=o.getNextIndex(t),e instanceof g){const n=e;n.parent===this?this.reorder(n,t):o.add(n,t)}else b(e)?e.then(n=>{this.destroyed||this.add(n,t)}):d.getLogger(this).error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(e,t){const o=this.layers;let n=o.getNextIndex(t);e.slice().forEach(s=>{s.parent!==this?(o.add(s,n),n+=1):this.reorder(s,n)})}findLayerById(e){return y(this.layers,"id",e)}findLayerByUid(e){return y(this.layers,"uid",e)}remove(e){return this.layers.remove(e)}removeMany(e){return this.layers.removeMany(e)}removeAll(){return this.layers.removeAll()}reorder(e,t){return this.layers.reorder(e,t)}layerAdded(e){}layerRemoved(e){}};return l([m()],r.prototype,"layers",null),r=l([p("esri.support.LayersMixin")],r),r};function h(i,r,a){if(i)for(let e=0,t=i.length;e<t;e++){const o=i.at(e);if(o[r]===a)return o;if((o==null?void 0:o.type)==="group"){const n=h(o.tables,r,a);if(n)return n}}}const H=i=>{let r=class extends i{constructor(...a){super(...a),this.tables=new f,this.addHandles([this.tables.on("after-add",e=>{const t=e.item;t.parent&&t.parent!==this&&"tables"in t.parent&&t.parent.tables.remove(t),t.parent=this,t.type!=="feature"&&d.getLogger(this).error(`Layer 'title:${t.title}, id:${t.id}' of type '${t.type}' is not supported as a table and will therefore be ignored.`)}),this.tables.on("after-remove",e=>{e.item.parent=null})])}destroy(){const a=this.tables.toArray();for(const e of a)e.destroy();this.tables.destroy()}set tables(a){this._set("tables",u(a,this._get("tables")))}findTableById(a){return h(this.tables,"id",a)}findTableByUid(a){return h(this.tables,"uid",a)}};return l([m()],r.prototype,"tables",null),r=l([p("esri.support.TablesMixin")],r),r};export{_ as a,F as d,H as n,T as t};
