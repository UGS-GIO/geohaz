import{e as h,c as W}from"./subclass-f7409b1b.js";import{y as d,S as E}from"./JSONSupport-acf2865c.js";import"./typedArrayUtil-2af43698.js";import{k as R,s as v,p as $,v as N}from"./promiseUtils-1d963c7c.js";import"./Error-21d1d076.js";import{u as H,j as z}from"./aaBoundingRect-aef00841.js";import{s as T}from"./SpatialReference-428523ee.js";import{j}from"./TileInfo-d188b444.js";import{b as q}from"./Bitmap-2b550e0b.js";import{e as I}from"./HighlightOptions-4299833f.js";import{e as B}from"./TileKey-a0a7eda8.js";const C=Math.PI/180;function U(i){return i*C}function k(i,e){const r=U(e.rotation),t=Math.abs(Math.cos(r)),s=Math.abs(Math.sin(r)),[o,n]=e.size;return i[0]=Math.round(n*s+o*t),i[1]=Math.round(n*t+o*s),i}function A(i,e,r,t){const[s,o]=e,[n,a]=t,l=.5*r;return i[0]=s-l*n,i[1]=o-l*a,i[2]=s+l*n,i[3]=o+l*a,i}const u=H(),c=[0,0],_=new B(0,0,0,0),y={container:null,fetchSource:null,requestUpdate:null,imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let p=class extends E{constructor(i){super(i),this._imagePromise=null,this.bitmaps=[],this.hidpi=y.hidpi,this.imageMaxWidth=y.imageMaxWidth,this.imageMaxHeight=y.imageMaxHeight,this.imageRotationSupported=y.imageRotationSupported,this.imageNormalizationSupported=y.imageNormalizationSupported,this.update=R(async(e,r)=>{if(v(r),!e.stationary||this.destroyed)return;const t=e.state,s=T(t.spatialReference),o=this.hidpi?e.pixelRatio:1,n=this.imageNormalizationSupported&&t.worldScreenWidth&&t.worldScreenWidth<t.size[0],a=this.imageMaxWidth??0,l=this.imageMaxHeight??0;n?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):k(c,t);const S=Math.floor(c[0]*o)>a||Math.floor(c[1]*o)>l,M=s&&(t.extent.xmin<s.valid[0]||t.extent.xmax>s.valid[1]),f=!this.imageNormalizationSupported&&M,w=!S&&!f,x=this.imageRotationSupported?t.rotation:0,b=this.container.children.slice();if(w){const m=n?t.paddedViewState.center:t.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(t,c,m,t.resolution,x,o,r)}else{let m=Math.min(a,l);f&&(m=Math.min(t.worldScreenWidth,m)),this._imagePromise=this._tiledExport(t,m,o,r)}try{const m=await this._imagePromise??[];v(r);const P=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=m;for(const g of b)m.includes(g)||P.push(g.fadeOut().then(()=>{g.remove(),g.destroy()}));for(const g of m)P.push(g.fadeIn());await Promise.all(P)}catch(m){this._imagePromise=null,$(m)}},5e3),this.updateExports=R(async e=>{const r=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;r.push(e(t).then(()=>{t.invalidateTexture(),t.requestRender()}))}this._imagePromise=N(r).then(()=>this._imagePromise=null),await this._imagePromise})}destroy(){this.bitmaps.forEach(i=>i.destroy()),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(i,e,r,t,s,o){const n=await this.fetchSource(i,Math.floor(e*s),Math.floor(r*s),{rotation:t,pixelRatio:s,signal:o});v(o);const a=new q(null,!0);return a.x=i.xmin,a.y=i.ymax,a.resolution=i.width/e,a.rotation=t,a.pixelRatio=s,a.opacity=0,this.container.addChild(a),await a.setSourceAsync(n,o),v(o),a}async _singleExport(i,e,r,t,s,o,n){A(u,r,t,e);const a=z(u,i.spatialReference);return[await this._export(a,e[0],e[1],s,o,n)]}_tiledExport(i,e,r,t){const s=j.create({size:e,spatialReference:i.spatialReference,scales:[i.scale]}),o=new I(s),n=o.getTileCoverage(i);if(!n)return null;const a=[];return n.forEach((l,S,M,f)=>{_.set(l,S,M,0),o.getTileBounds(u,_);const w=z(u,i.spatialReference);a.push(this._export(w,e,e,0,r,t).then(x=>(f!==0&&(_.set(l,S,M,f),o.getTileBounds(u,_),x.x=u[0],x.y=u[3]),x)))}),Promise.all(a)}};h([d()],p.prototype,"_imagePromise",void 0),h([d()],p.prototype,"bitmaps",void 0),h([d()],p.prototype,"container",void 0),h([d()],p.prototype,"fetchSource",void 0),h([d()],p.prototype,"hidpi",void 0),h([d()],p.prototype,"imageMaxWidth",void 0),h([d()],p.prototype,"imageMaxHeight",void 0),h([d()],p.prototype,"imageRotationSupported",void 0),h([d()],p.prototype,"imageNormalizationSupported",void 0),h([d()],p.prototype,"requestUpdate",void 0),h([d()],p.prototype,"updating",null),p=h([W("esri.views.2d.layers.support.ExportStrategy")],p);const Z=p;export{Z as v};
