import"./geometry-31b45acd.js";import{p as h}from"./workers-1be2b889.js";import{x as l}from"./Extent-2b4578b8.js";import{y}from"./jsonUtils-2c7f966c.js";import"./subclass-f7409b1b.js";import"./typedArrayUtil-2af43698.js";import"./Error-21d1d076.js";import"./promiseUtils-1d963c7c.js";import"./Polyline-013cde1f.js";import"./JSONSupport-acf2865c.js";import"./time-0817624a.js";import"./SpatialReference-428523ee.js";import"./jsonMap-5ba4a9c2.js";import"./request-a10d6950.js";import"./assets-6fd92e57.js";import"./aaBoundingRect-aef00841.js";import"./Axis-30be7e73.js";import"./mathUtils-19b6edfc.js";import"./typeUtils-3056a943.js";import"./Connection-2d969448.js";import"./SimpleObservable-ae589a25.js";import"./intl-fe039018.js";import"./date-7940da18.js";import"./locale-bde6d0f6.js";import"./datetime-7e00d9ef.js";import"./messages-2d262041.js";import"./cast-e7a2f9aa.js";function n(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(t=>y(t)):y(e)}function x(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function w(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function a(e,t){return(await w()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function d(e,t){const r=await w();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function M(e){return a("extendedSpatialReferenceInfo",[e])}async function Q(e,t){return o(await a("clip",[n(e),e,t]))}async function U(e,t){return o(await a("cut",[n(e),e,t]))}function X(e,t){return a("contains",[n(e),e,t])}function Y(e,t){return a("crosses",[n(e),e,t])}function Z(e,t,r){return a("distance",[n(e),e,t,r])}function _(e,t){return a("equals",[n(e),e,t])}function ee(e,t){return a("intersects",[n(e),e,t])}function te(e,t){return a("touches",[n(e),e,t])}function re(e,t){return a("within",[n(e),e,t])}function ae(e,t){return a("disjoint",[n(e),e,t])}function ne(e,t){return a("overlaps",[n(e),e,t])}function ie(e,t,r){return a("relate",[n(e),e,t,r])}function oe(e){return a("isSimple",[n(e),e])}async function ce(e){return o(await a("simplify",[n(e),e]))}async function se(e,t=!1){return o(await a("convexHull",[n(e),e,t]))}async function ue(e,t){return o(await a("difference",[n(e),e,t]))}async function fe(e,t){return o(await a("symmetricDifference",[n(e),e,t]))}async function le(e,t){return o(await a("intersect",[n(e),e,t]))}async function pe(e,t=null){const r=x(e,t);return o(await a("union",[n(r),r]))}async function me(e,t,r,i,c,u){return o(await a("offset",[n(e),e,t,r,i,c,u]))}async function ye(e,t,r,i=!1){const c=[n(e),e,t,r,i];return o(await a("buffer",c))}async function we(e,t,r,i,c,u){const g=[n(e),e,t,r,i,c,u];return o(await a("geodesicBuffer",g))}async function de(e,t,r=!0){const i=await a("nearestCoordinate",[n(e),e,t,r]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function ge(e,t){const r=await a("nearestVertex",[n(e),e,t]);return{...r,coordinate:l.fromJSON(r.coordinate)}}async function he(e,t,r,i){return(await a("nearestVertices",[n(e),e,t,r,i])).map(c=>({...c,coordinate:l.fromJSON(c.coordinate)}))}function m(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function xe(e,t,r){if(e==null)throw new s;const i=e.spatialReference;if((r=r??m(e))==null)throw new s;const c=e.constructor.fromJSON(await a("rotate",[i,e,t,r]));return c.spatialReference=i,c}async function Se(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function Re(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function Ae(e,t,r,i){return o(await a("generalize",[n(e),e,t,r,i]))}async function Oe(e,t,r){return o(await a("densify",[n(e),e,t,r]))}async function De(e,t,r,i=0){return o(await a("geodesicDensify",[n(e),e,t,r,i]))}function Je(e,t){return a("planarArea",[n(e),e,t])}function Ne(e,t){return a("planarLength",[n(e),e,t])}function Le(e,t,r){return a("geodesicArea",[n(e),e,t,r])}function Te(e,t,r){return a("geodesicLength",[n(e),e,t,r])}async function Ve(e,t){return o(await a("intersectLinesToPoints",[n(e),e,t]))}async function ve(e,t){await d("changeDefaultSpatialReferenceTolerance",[e,t])}async function Ee(e){await d("clearDefaultSpatialReferenceTolerance",[e])}class s extends Error{constructor(){super("Illegal Argument Exception")}}export{ye as buffer,ve as changeDefaultSpatialReferenceTolerance,Ee as clearDefaultSpatialReferenceTolerance,Q as clip,X as contains,se as convexHull,Y as crosses,U as cut,Oe as densify,ue as difference,ae as disjoint,Z as distance,_ as equals,M as extendedSpatialReferenceInfo,Se as flipHorizontal,Re as flipVertical,Ae as generalize,Le as geodesicArea,we as geodesicBuffer,De as geodesicDensify,Te as geodesicLength,le as intersect,Ve as intersectLinesToPoints,ee as intersects,oe as isSimple,de as nearestCoordinate,ge as nearestVertex,he as nearestVertices,me as offset,ne as overlaps,Je as planarArea,Ne as planarLength,ie as relate,xe as rotate,ce as simplify,fe as symmetricDifference,te as touches,pe as union,re as within};
