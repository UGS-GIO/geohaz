class o{constructor(s=[],t=[],e=!1){this.lengths=s??[],this.coords=t??[],this.hasIndeterminateRingOrder=e}static fromRect(s){const[t,e,r,n]=s,h=r-t,i=n-e;return new o([5],[t,e,h,0,0,i,-h,0,0,-i])}get isPoint(){return this.lengths.length===0}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((s,t)=>s+t)}forEachVertex(s){let t=0;this.lengths.length||s(this.coords[0],this.coords[1]);for(let e=0;e<this.lengths.length;e++){const r=this.lengths[e];for(let n=0;n<r;n++)s(this.coords[2*(n+t)],this.coords[2*(n+t)+1]);t+=r}}deltaDecode(){const s=this.clone(),{coords:t,lengths:e}=s;let r=0;for(const n of e){for(let h=1;h<n;h++)t[2*(r+h)]+=t[2*(r+h)-2],t[2*(r+h)+1]+=t[2*(r+h)-1];r+=n}return s}clone(s){if(this.lengths.length===0)return new o([],[this.coords[0],this.coords[1]]);const t=(this.lengths.length===0?1:this.lengths.reduce((r,n)=>r+n))*2,e=this.coords.slice(0,t);return s?(s.set(e),new o(this.lengths,s,this.hasIndeterminateRingOrder)):new o(Array.from(this.lengths),Array.from(e),this.hasIndeterminateRingOrder)}}export{o as e};
