import{w as D,q as S}from"./typedArrayUtil-2af43698.js";import{O as C}from"./quat-064ab1d0.js";import{e as x}from"./quatf64-81e039e4.js";import{E as k}from"./mathUtils-19b6edfc.js";import{t as v,n as A}from"./vec3f32-ad1dc57f.js";import{f as w}from"./SpatialReference-428523ee.js";import{n as F}from"./projectBuffer-af7b4ad9.js";import{a as R,b as U,d as B}from"./PointCloudUniqueValueRenderer-78133231.js";import{w as J,l as N,c as V,I as q}from"./I3SBinaryReader-2a065a27.js";import{O as T}from"./orientedBoundingBox-27e96351.js";import"./mat3f64-e19cdcb8.js";import"./vec42-a95eff2d.js";import"./subclass-f7409b1b.js";import"./Error-21d1d076.js";import"./promiseUtils-1d963c7c.js";import"./JSONSupport-acf2865c.js";import"./time-0817624a.js";import"./jsonMap-5ba4a9c2.js";import"./request-a10d6950.js";import"./assets-6fd92e57.js";import"./enumeration-4a4e87c4.js";import"./ColorStop-6cee3909.js";import"./Color-e1a6dfab.js";import"./colorUtils-ac6863dc.js";import"./VertexAttribute-c2df436e.js";import"./mat3-def297a7.js";import"./mat4f64-9a8384aa.js";import"./vec4f64-430e4feb.js";import"./computeTranslationToOriginAndRotation-3ac32984.js";import"./mat4-a6ac6b0f.js";import"./plane-f835f029.js";import"./vec2f64-b65bfd66.js";import"./ViewingMode-fb6259a5.js";function _(c,t,i,n){const{rendererJSON:s,isRGBRenderer:p}=c;let e=null,l=null;if(t&&p)e=t;else if(t&&(s==null?void 0:s.type)==="pointCloudUniqueValueRenderer"){l=R.fromJSON(s);const o=l.colorUniqueValueInfos;e=new Uint8Array(3*n);const f=g(l.fieldTransformType);for(let r=0;r<n;r++){const u=(f?f(t[r]):t[r])+"";for(let a=0;a<o.length;a++)if(o[a].values.includes(u)){e[3*r]=o[a].color.r,e[3*r+1]=o[a].color.g,e[3*r+2]=o[a].color.b;break}}}else if(t&&(s==null?void 0:s.type)==="pointCloudStretchRenderer"){l=U.fromJSON(s);const o=l.stops;e=new Uint8Array(3*n);const f=g(l.fieldTransformType);for(let r=0;r<n;r++){const u=f?f(t[r]):t[r],a=o.length-1;if(u<o[0].value)e[3*r]=o[0].color.r,e[3*r+1]=o[0].color.g,e[3*r+2]=o[0].color.b;else if(u>=o[a].value)e[3*r]=o[a].color.r,e[3*r+1]=o[a].color.g,e[3*r+2]=o[a].color.b;else for(let m=1;m<o.length;m++)if(u<o[m].value){const b=(u-o[m-1].value)/(o[m].value-o[m-1].value);e[3*r]=o[m].color.r*b+o[m-1].color.r*(1-b),e[3*r+1]=o[m].color.g*b+o[m-1].color.g*(1-b),e[3*r+2]=o[m].color.b*b+o[m-1].color.b*(1-b);break}}}else if(t&&(s==null?void 0:s.type)==="pointCloudClassBreaksRenderer"){l=B.fromJSON(s);const o=l.colorClassBreakInfos;e=new Uint8Array(3*n);const f=g(l.fieldTransformType);for(let r=0;r<n;r++){const u=f?f(t[r]):t[r];for(let a=0;a<o.length;a++)if(u>=o[a].minValue&&u<=o[a].maxValue){e[3*r]=o[a].color.r,e[3*r+1]=o[a].color.g,e[3*r+2]=o[a].color.b;break}}}else e=new Uint8Array(3*n).fill(255);if(i&&(l!=null&&l.colorModulation)){const o=l.colorModulation.minValue,f=l.colorModulation.maxValue,r=.3;for(let u=0;u<n;u++){const a=i[u],m=a>=f?1:a<=o?r:r+(1-r)*(a-o)/(f-o);e[3*u]=m*e[3*u],e[3*u+1]=m*e[3*u+1],e[3*u+2]=m*e[3*u+2]}}return e}function E(c,t){if(c.encoding==null||c.encoding===""){const i=J(t,c);if(i.vertexAttributes.position==null)return;const n=N(t,i.vertexAttributes.position),s=i.header.fields,p=[s.offsetX,s.offsetY,s.offsetZ],e=[s.scaleX,s.scaleY,s.scaleZ],l=n.length/3,o=new Float64Array(3*l);for(let f=0;f<l;f++)o[3*f]=n[3*f]*e[0]+p[0],o[3*f+1]=n[3*f+1]*e[1]+p[1],o[3*f+2]=n[3*f+2]*e[2]+p[2];return o}if(c.encoding==="lepcc-xyz")return V(t).result}function h(c,t,i){return c!=null&&c.attributeInfo.useElevation?t?z(t,i):null:c!=null&&c.attributeInfo.storageInfo?q(c.attributeInfo.storageInfo,c.buffer,i):null}function z(c,t){const i=new Float64Array(t);for(let n=0;n<t;n++)i[n]=c[3*n+2];return i}function P(c,t,i,n,s){const p=c.length/3;let e=0;for(let l=0;l<p;l++){let o=!0;for(let f=0;f<n.length&&o;f++){const{filterJSON:r}=n[f],u=s[f].values[l];switch(r.type){case"pointCloudValueFilter":{const a=r.mode==="exclude";r.values.includes(u)===a&&(o=!1);break}case"pointCloudBitfieldFilter":{const a=M(r.requiredSetBits),m=M(r.requiredClearBits);(u&a)===a&&!(u&m)||(o=!1);break}case"pointCloudReturnFilter":{const a=15&u,m=u>>>4&15,b=m>1,$=a===1,I=a===m;let y=!1;for(const d of r.includedReturns)if(d==="last"&&I||d==="firstOfMany"&&$&&b||d==="lastOfMany"&&I&&b||d==="single"&&!b){y=!0;break}y||(o=!1);break}}}o&&(i[e]=l,c[3*e]=c[3*l],c[3*e+1]=c[3*l+1],c[3*e+2]=c[3*l+2],t[3*e]=t[3*l],t[3*e+1]=t[3*l+1],t[3*e+2]=t[3*l+2],e++)}return e}function g(c){switch(c){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function M(c){let t=0;for(const i of c||[])t|=1<<i;return t}class X{transform(t){const i=this._transform(t),n=[i.points.buffer,i.rgb.buffer];i.pointIdFilterMap!=null&&n.push(i.pointIdFilterMap.buffer);for(const s of i.attributes)"buffer"in s.values&&D(s.values.buffer)&&s.values.buffer!==i.rgb.buffer&&n.push(s.values.buffer);return Promise.resolve({result:i,transferList:n})}_transform(t){const i=E(t.schema,t.geometryBuffer);let n=i.length/3,s=null;const p=new Array,e=h(t.primaryAttributeData,i,n);t.primaryAttributeData!=null&&e&&p.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:e});const l=h(t.modulationAttributeData,i,n);t.modulationAttributeData!=null&&l&&p.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:l});let o=_(t.rendererInfo,e,l,n);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const r=t.filterAttributesData.filter(S).map(u=>{const a=h(u,i,n),m={attributeInfo:u.attributeInfo,values:a};return p.push(m),m});s=new Uint32Array(n),n=P(i,o,s,t.filterInfo,r)}for(const r of t.userAttributesData){const u=h(r,i,n);p.push({attributeInfo:r.attributeInfo,values:u})}3*n<o.length&&(o=new Uint8Array(o.buffer.slice(0,3*n))),this._applyElevationOffsetInPlace(i,n,t.elevationOffset);const f=this._transformCoordinates(i,n,T.fromData(t.obbData),w.fromJSON(t.inSR),w.fromJSON(t.outSR));return{obbData:t.obbData,points:f,rgb:o,attributes:p,pointIdFilterMap:s}}_transformCoordinates(t,i,n,s,p){if(!F(t,s,0,t,p,0,i))throw new Error("Can't reproject");const e=v(n.center),l=A(),o=A(),f=v(n.halfSize);C(O,n.quaternion);const r=new Float32Array(3*i);for(let u=0;u<i;u++){let a=3*u;l[0]=t[a]-e[0],l[1]=t[a+1]-e[1],l[2]=t[a+2]-e[2],k(o,l,O),f[0]=Math.max(f[0],Math.abs(o[0])),f[1]=Math.max(f[1],Math.abs(o[1])),f[2]=Math.max(f[2],Math.abs(o[2])),r[a++]=l[0],r[a++]=l[1],r[a]=l[2]}return n.halfSize=f,r}_applyElevationOffsetInPlace(t,i,n){if(n!==0)for(let s=0;s<i;s++)t[3*s+2]+=n}}const O=x();function Ot(){return new X}export{Ot as default};
