import{a as j,d as G,q as k}from"./typedArrayUtil-2af43698.js";import{a as u}from"./Error-21d1d076.js";import{i as E}from"./originUtils-cfe4feaf.js";import{$ as q,w as g,I as x,v as N,j as z,y as B,P as C,l as O,d as V,c as I}from"./utils-df330680.js";import{p as f}from"./arcgisLayerUrl-0c479f71.js";import{t as H}from"./fetchService-b7ffffb9.js";import{L as Q}from"./layerUtils-c805b05c.js";import{a as W}from"./lazyLayerLoader-b21a171b.js";import{l as F,a as b,f as p,u as $,i as T}from"./portalItemUtils-8aceb0b8.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./Portal-cb507469.js";import"./request-a10d6950.js";import"./JSONSupport-acf2865c.js";import"./subclass-f7409b1b.js";import"./promiseUtils-1d963c7c.js";import"./time-0817624a.js";import"./Loadable-8a1ead8b.js";import"./Promise-ec74e14b.js";import"./Extent-2b4578b8.js";import"./SpatialReference-428523ee.js";import"./jsonMap-5ba4a9c2.js";import"./assets-6fd92e57.js";import"./cast-e7a2f9aa.js";import"./locale-bde6d0f6.js";import"./PortalItem-9d3416e3.js";import"./persistableUrlUtils-ca6bb38d.js";import"./jsonContext-70ccb9b3.js";import"./saveAPIKeyUtils-7fbece8f.js";import"./saveUtils-534df74b.js";import"./requestPresets-cacb0d18.js";import"./projection-41da473c.js";import"./SimpleObservable-ae589a25.js";import"./mathUtils-19b6edfc.js";import"./Polyline-013cde1f.js";import"./aaBoundingRect-aef00841.js";import"./Axis-30be7e73.js";import"./projectBuffer-af7b4ad9.js";import"./zscale-d7e12601.js";const h="Feature Service",w="feature-layer-utils",X=`${w}-save`,Z=`${w}-save-as`,m=`${w}-saveall`,y=`${w}-saveall-as`;function v(r){return{isValid:Q(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function J(r){const t=[],e=[];for(const{layer:a,layerJSON:i}of r)a.isTable?e.push(i):t.push(i);return{layers:t,tables:e}}function M(r){return J([r])}async function R(r,t){return/\/\d+\/?$/.test(r.url)?M(t[0]):D(t,r)}async function D(r,t){if(r.reverse(),!t)return J(r);const e=await rr(t,r);for(const a of r)U(a.layer,a.layerJSON,e);return ar(e,r),e}async function rr(r,t){let e=await r.fetchData("json");if(tr(e))return e;e||(e={}),er(e);const{layer:{url:a,customParameters:i,apiKey:n}}=t[0];return await or(e,{url:a??"",customParameters:i,apiKey:n},t.map(o=>o.layer.layerId)),e}function tr(r){return!!(r&&Array.isArray(r.layers)&&Array.isArray(r.tables))}function er(r){r.layers||(r.layers=[]),r.tables||(r.tables=[])}function ar(r,t){const e=[],a=[];for(const{layer:i}of t){const{isTable:n,layerId:o}=i;n?a.push(o):e.push(o)}A(r.layers,e),A(r.tables,a)}function A(r,t){if(r.length<2)return;const e=[];for(const{id:a}of r)e.push(a);j(e.sort(L),t.slice().sort(L))&&r.sort((a,i)=>{const n=t.indexOf(a.id),o=t.indexOf(i.id);return n<o?-1:n>o?1:0})}function L(r,t){return r<t?-1:r>t?1:0}async function or(r,t,e){const{url:a,customParameters:i,apiKey:n}=t,{serviceJSON:o,layersJSON:s}=await H(a,{customParameters:i,apiKey:n}),l=P(r.layers,o.layers,e),c=P(r.tables,o.tables,e);r.layers=l.itemResources,r.tables=c.itemResources;const d=[...l.added,...c.added],_=s?[...s.layers,...s.tables]:[];await nr(r,d,a,_)}function P(r,t,e){const a=G(r,t,(n,o)=>n.id===o.id);r=r.filter(n=>!a.removed.some(o=>o.id===n.id));const i=a.added;return i.forEach(({id:n})=>{r.push({id:n})}),{itemResources:r,added:i.filter(({id:n})=>!e.includes(n))}}async function nr(r,t,e,a){const i=await ir(t),n=t.map(({id:o,type:s})=>new(i.get(s))({url:e,layerId:o,sourceJSON:a.find(({id:l})=>l===o)}));await Promise.allSettled(n.map(o=>o.load())),n.forEach(o=>{const{layerId:s,loaded:l,defaultPopupTemplate:c}=o;if(!l||c==null)return;const d={id:s,popupInfo:c.toJSON()};o.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=o.operationalLayerType),U(o,d,r)})}async function ir(r){const t=[];r.forEach(({type:i})=>{const n=sr(i),o=W[n];t.push(o())});const e=await Promise.all(t),a=new Map;return r.forEach(({type:i},n)=>{a.set(i,e[n])}),a}function sr(r){let t;switch(r){case"Feature Layer":case"Table":t="FeatureLayer";break;case"Oriented Imagery Layer":t="OrientedImageryLayer";break;case"Catalog Layer":t="CatalogLayer"}return t}function U(r,t,e){r.isTable?S(e.tables,t):S(e.layers,t)}function S(r,t){const e=r.findIndex(({id:a})=>a===t.id);e===-1?r.push(t):r[e]=t}function K(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function lr(r,t){const e=r.map(a=>a.portalItem.id);if(new Set(e).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function Y(r,t){const e=r.map(a=>a.layerId);if(new Set(e).size!==e.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function cr(r){K(r,m),await Promise.all(r.map(t=>t.load()));for(const t of r)O(t,m,v),V({layer:t,itemType:h,errorNamePrefix:m});lr(r,m),Y(r,m)}async function pr(r,t){const{url:e,layerId:a,title:i,fullExtent:n,isTable:o}=r,s=f(e);t.url=(s==null?void 0:s.serverType)==="FeatureServer"?e:`${e}/${a}`,t.title||(t.title=i),t.extent=null,o||n==null||(t.extent=await F(n)),b(t,p.METADATA),b(t,p.MULTI_LAYER),T(t,p.SINGLE_LAYER),o&&T(t,p.TABLE)}function ur(r,t){for(const n of r){const o=n.parsedUrl.path,s=f(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,I(n,`has unsupported url pattern: ${o}`),{layer:n});const c=s==null?void 0:s.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new u(`${t}:invalid-parameters`,I(n,`has unsupported server type: ${c}`),{layer:n});if(c==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const e=f(r[0].parsedUrl.path),a=e==null?void 0:e.url.path;if(!r.every(n=>{const o=f(n.parsedUrl.path);return(o==null?void 0:o.url.path)===a}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function mr(r){K(r,y),await Promise.all(r.map(t=>t.load()));for(const t of r)O(t,y,v);ur(r,y),Y(r,y)}async function yr(r,t){let e=0,a=0;for(const{isTable:o}of t)o?a++:e++;const i=t[0].parsedUrl.path,n=f(i);if(r.url=(n==null?void 0:n.serverType)==="FeatureServer"?n.url.path:i,r.title||(r.title=n.title),r.extent=null,e>0){const o=t.map(s=>s.fullExtent).filter(k).reduce((s,l)=>s.clone().union(l));o&&(r.extent=await F(o))}b(r,p.METADATA),$(r,p.MULTI_LAYER,t.length>1),$(r,p.SINGLE_LAYER,t.length===1),$(r,p.TABLE,a>0&&e===0),N(r)}async function Xr(r,t){return q({layer:r,itemType:h,validateLayer:v,createItemData:(e,a)=>R(a,[e]),errorNamePrefix:X},t)}async function Zr(r,t){await cr(r);const e=r[0].portalItem,a=g(e),i=await Promise.all(r.map(o=>x(o,a,t))),n=await R(e,r.map((o,s)=>({layer:o,layerJSON:i[s]})));return N(e),await e.update({data:n}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),E(a),e.clone()}async function rt(r,t,e){return z({layer:r,itemType:h,validateLayer:v,createItemData:(a,i)=>Promise.resolve(M(a)),errorNamePrefix:Z,newItem:t,setItemProperties:pr},e)}async function tt(r,t,e){await mr(r);const a=B({itemType:h,errorNamePrefix:y,newItem:t}),i=g(a),n=await Promise.all(r.map(s=>x(s,i,e))),o=await D(r.map((s,l)=>({layer:s,layerJSON:n[l]})));await yr(a,r),await C(a,o,e);for(const s of r)s.portalItem=a.clone();return E(i),a}export{Xr as save,Zr as saveAll,tt as saveAllAs,rt as saveAs};
