import{h as l}from"./typedArrayUtil-2af43698.js";import{s}from"./PooledRBush-7b613e7a.js";import{g as h}from"./meshVertexSpaceUtils-a98cf1bd.js";import{P as u}from"./georeference-a2be6426.js";import"./subclass-f7409b1b.js";import"./Error-21d1d076.js";import"./promiseUtils-1d963c7c.js";import"./quickselect-fcce738b.js";import"./_commonjsHelpers-2f3e7994.js";import"./JSONSupport-acf2865c.js";import"./time-0817624a.js";import"./Extent-2b4578b8.js";import"./SpatialReference-428523ee.js";import"./jsonMap-5ba4a9c2.js";import"./request-a10d6950.js";import"./assets-6fd92e57.js";import"./cast-e7a2f9aa.js";import"./MeshLocalVertexSpace-48f1035e.js";import"./Clonable-b71fa929.js";import"./enumeration-4a4e87c4.js";import"./mathUtils-19b6edfc.js";import"./vec3-10e9217f.js";import"./mat3f64-e19cdcb8.js";import"./mat4-a6ac6b0f.js";import"./mat4f64-9a8384aa.js";import"./mat3-def297a7.js";import"./projection-41da473c.js";import"./SimpleObservable-ae589a25.js";import"./Polyline-013cde1f.js";import"./aaBoundingRect-aef00841.js";import"./Axis-30be7e73.js";import"./projectBuffer-af7b4ad9.js";import"./zscale-d7e12601.js";import"./computeTranslationToOriginAndRotation-3ac32984.js";import"./DoubleArray-d7e400b4.js";import"./quat-064ab1d0.js";import"./quatf64-81e039e4.js";import"./vec42-a95eff2d.js";import"./vec4f64-430e4feb.js";import"./BufferView-6e304e0e.js";import"./vec2-f44efd17.js";class ot{async createIndex(t,r){var a;const i=new Array;if(!((a=t.vertexAttributes)!=null&&a.position))return new s;const n=this._createMeshData(t),e=r!=null?await r.invoke("createIndexThread",n,{transferList:i}):this.createIndexThread(n).result;return this._createPooledRBush().fromJSON(e)}createIndexThread(t){const r=new Float64Array(t.position),i=this._createPooledRBush();return t.components?this._createIndexComponentsThread(i,r,t.components.map(n=>new Uint32Array(n))):this._createIndexAllThread(i,r)}_createIndexAllThread(t,r){const i=new Array(r.length/9);let n=0;for(let e=0;e<r.length;e+=9)i[n++]=c(r,e,e+3,e+6);return t.load(i),{result:t.toJSON()}}_createIndexComponentsThread(t,r,i){let n=0;for(const m of i)n+=m.length/3;const e=new Array(n);let a=0;for(const m of i)for(let p=0;p<m.length;p+=3)e[a++]=c(r,3*m[p],3*m[p+1],3*m[p+2]);return t.load(e),{result:t.toJSON()}}_createMeshData(t){const r=(h(t.vertexSpace)?u({position:t.vertexAttributes.position,normal:null,tangent:null},t.vertexSpace,t.transform,t.spatialReference).position:t.vertexAttributes.position).buffer;return!t.components||t.components.some(i=>!i.faces)?{position:r}:{position:r,components:t.components.map(i=>i.faces)}}_createPooledRBush(){return new s(9,l("esri-csp-restrictions")?t=>t:[".minX",".minY",".maxX",".maxY"])}}function c(o,t,r,i){return{minX:Math.min(o[t],o[r],o[i]),maxX:Math.max(o[t],o[r],o[i]),minY:Math.min(o[t+1],o[r+1],o[i+1]),maxY:Math.max(o[t+1],o[r+1],o[i+1]),p0:[o[t],o[t+1],o[t+2]],p1:[o[r],o[r+1],o[r+2]],p2:[o[i],o[i+1],o[i+2]]}}export{ot as default};
