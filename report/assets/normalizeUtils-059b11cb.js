import{c as _,s as B,a as E}from"./Error-21d1d076.js";import{m as N,j as k}from"./Polyline-013cde1f.js";import{r as P,o as q,i as w,s as X}from"./normalizeUtilsCommon-c4e9ddb1.js";import{g as C,s as A}from"./SpatialReference-428523ee.js";import{d as z,R as G}from"./Extent-2b4578b8.js";import"./geometry-31b45acd.js";import{U as D,I as H}from"./request-a10d6950.js";import{p as F,y as K}from"./jsonUtils-2c7f966c.js";import{f as Q}from"./utils-3234cfff.js";import{r as V,o as Y}from"./utils-ed91a700.js";async function Z(e,n,l,s){const t=Q(e),i=n[0].spatialReference,r={...s,responseType:"json",query:{...t.query,f:"json",sr:C(i),target:JSON.stringify({geometryType:F(n[0]),geometries:n}),cutter:JSON.stringify(l)}},o=await D(t.path+"/cut",r),{cutIndexes:a,geometries:u=[]}=o.data;return{cutIndexes:a,geometries:u.map(p=>{const g=K(p);return g.spatialReference=i,g})}}async function ee(e,n,l){const s=typeof e=="string"?H(e):e,t=n[0].spatialReference,i=F(n[0]),r={...l,query:{...s.query,f:"json",sr:C(t),geometries:JSON.stringify(V(n))}},{data:o}=await D(s.path+"/simplify",r);return Y(o.geometries,i,t)}const W=()=>B.getLogger("esri.geometry.support.normalizeUtils");function te(e){return e.type==="polygon"}function ne(e){return e[0].type==="polygon"}function se(e){return e[0].type==="polyline"}function J(e){const n=[];let l=0,s=0;for(let t=0;t<e.length;t++){const i=e[t];let r=null;for(let o=0;o<i.length;o++)r=i[o],n.push(r),o===0?(l=r[0],s=l):(l=Math.min(l,r[0]),s=Math.max(s,r[0]));r&&n.push([(l+s)/2,0])}return n}function oe(e,n){if(!(e instanceof N||e instanceof k)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw W().error(t),new E(t)}const l=q(e),s=[];for(const t of l){const i=[];s.push(i),i.push([t[0][0],t[0][1]]);for(let r=0;r<t.length-1;r++){const o=t[r][0],a=t[r][1],u=t[r+1][0],p=t[r+1][1],g=Math.sqrt((u-o)*(u-o)+(p-a)*(p-a)),h=(p-a)/g,x=(u-o)/g,m=g/n;if(m>1){for(let R=1;R<=m-1;R++){const b=R*n,c=x*b+o,f=h*b+a;i.push([c,f])}const $=(g+Math.floor(m-1)*n)/2,j=x*$+o,S=h*$+a;i.push([j,S])}i.push([u,p])}}return te(e)?new k({rings:s,spatialReference:e.spatialReference}):new N({paths:s,spatialReference:e.spatialReference})}function O(e,n,l){if(n){const s=oe(e,1e6);e=G(s,!0)}return l&&(e=X(e,l)),e}function T(e,n,l){if(Array.isArray(e)){const s=e[0];if(s>n){const t=w(s,n);e[0]=s+t*(-2*n)}else if(s<l){const t=w(s,l);e[0]=s+t*(-2*l)}}else{const s=e.x;if(s>n){const t=w(s,n);e=e.clone().offset(t*(-2*n),0)}else if(s<l){const t=w(s,l);e=e.clone().offset(t*(-2*l),0)}}return e}function re(e,n){let l=-1;for(let s=0;s<n.cutIndexes.length;s++){const t=n.cutIndexes[s],i=n.geometries[s],r=q(i);for(let o=0;o<r.length;o++){const a=r[o];a.some(u=>{if(u[0]<180)return!0;{let p=0;for(let h=0;h<a.length;h++){const x=a[h][0];p=x>p?x:p}p=Number(p.toFixed(9));const g=-360*w(p,180);for(let h=0;h<a.length;h++){const x=i.getPoint(o,h);i.setPoint(o,h,x.clone().offset(g,0))}return!0}})}if(t===l){if(ne(e))for(const o of q(i))e[t]=e[t].addRing(o);else if(se(e))for(const o of q(i))e[t]=e[t].addPath(o)}else l=t,e[t]=i}return e}async function ie(e,n,l){if(!Array.isArray(e))return ie([e],n);n&&typeof n!="string"&&W().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:(n==null?void 0:n.url)??_.geometryServiceUrl;let t,i,r,o,a,u,p,g,h=0;const x=[],m=[];for(const c of e)if(c!=null)if(t||(t=c.spatialReference,i=A(t),r=t.isWebMercator,u=r?102100:4326,o=P[u].maxX,a=P[u].minX,p=P[u].plus180Line,g=P[u].minus180Line),i)if(c.type==="mesh")m.push(c);else if(c.type==="point")m.push(T(c.clone(),o,a));else if(c.type==="multipoint"){const f=c.clone();f.points=f.points.map(y=>T(y,o,a)),m.push(f)}else if(c.type==="extent"){const f=c.clone()._normalize(!1,!1,i);m.push(f.rings?new k(f):f)}else if(c.extent){const f=c.extent,y=w(f.xmin,a)*(2*o);let d=y===0?c.clone():X(c.clone(),y);f.offset(y,0),f.intersects(p)&&f.xmax!==o?(h=f.xmax>h?f.xmax:h,d=O(d,r),x.push(d),m.push("cut")):f.intersects(g)&&f.xmin!==a?(h=f.xmax*(2*o)>h?f.xmax*(2*o):h,d=O(d,r,360),x.push(d),m.push("cut")):m.push(d)}else m.push(c.clone());else m.push(c);else m.push(c);let $=w(h,o),j=-90;const S=$,R=new N;for(;$>0;){const c=360*$-180;R.addPath([[c,j],[c,-1*j]]),j*=-1,$--}if(x.length>0&&S>0){const c=re(x,await Z(s,x,R,l)),f=[],y=[];for(let M=0;M<m.length;M++){const v=m[M];if(v!=="cut")y.push(v);else{const L=c.shift(),I=e[M];I!=null&&I.type==="polygon"&&I.rings&&I.rings.length>1&&L.rings.length>=I.rings.length?(f.push(L),y.push("simplify")):y.push(r?z(L):L)}}if(!f.length)return y;const d=await ee(s,f,l),U=[];for(let M=0;M<y.length;M++){const v=y[M];v!=="simplify"?U.push(v):U.push(r?z(d.shift()):d.shift())}return U}const b=[];for(let c=0;c<m.length;c++){const f=m[c];if(f!=="cut")b.push(f);else{const y=x.shift();b.push(r===!0?z(y):y)}}return b}function xe(e){if(!e)return null;const n=e.extent;if(!n)return null;const l=e.spatialReference&&A(e.spatialReference);if(!l)return n;const[s,t]=l.valid,i=2*t,{width:r}=n;let o,{xmin:a,xmax:u}=n;if([a,u]=[u,a],e.type==="extent"||r===0||r<=t||r>i||a<s||u>t)return n;switch(e.type){case"polygon":if(!(e.rings.length>1))return n;o=J(e.rings);break;case"polyline":if(!(e.paths.length>1))return n;o=J(e.paths);break;case"multipoint":o=e.points}const p=n.clone();for(let g=0;g<o.length;g++){let h=o[g][0];h<0?(h+=t,u=Math.max(h,u)):(h-=t,a=Math.min(h,a))}return p.xmin=a,p.xmax=u,p.width<r?(p.xmin-=t,p.xmax-=t,p):n}function de(e,n,l){const s=A(l);if(s==null)return e;const[t,i]=s.valid,r=2*i;let o=0,a=0;n>i?o=Math.ceil(Math.abs(n-i)/r):n<t&&(o=-Math.ceil(Math.abs(n-t)/r)),e>i?a=Math.ceil(Math.abs(e-i)/r):e<t&&(a=-Math.ceil(Math.abs(e-t)/r));let u=e+(o-a)*r;const p=u-n;return p>i?u-=r:p<t&&(u+=r),u}function Me(e,n){const l=A(n);if(l){const[s,t]=l.valid,i=t-s;if(e<s)for(;e<s;)e+=i;if(e>t)for(;e>t;)e-=i}return e}export{Me as L,oe as M,de as P,ie as R,xe as v};
